From 76025609972111f2e6b51d7f16470334f918e740 Mon Sep 17 00:00:00 2001
From: Astridxx <muratkozan350@gmail.com>
Date: Sat, 12 Aug 2023 10:20:38 +0300
Subject: [PATCH] core: touch response optimizations

---
 core/java/android/view/Choreographer.java     | 77 +++++++++++++++++-
 .../java/android/view/InputEventReceiver.java | 15 ++++
 core/java/android/widget/AbsListView.java     | 81 ++++++++++++++++++-
 core/jni/android_view_InputEventReceiver.cpp  | 32 +++++++-
 4 files changed, 200 insertions(+), 5 deletions(-)

diff --git a/core/java/android/view/Choreographer.java b/core/java/android/view/Choreographer.java
index be172f748b55f..a7ee21338e082 100644
--- a/core/java/android/view/Choreographer.java
+++ b/core/java/android/view/Choreographer.java
@@ -84,6 +84,7 @@ public final class Choreographer {
 
     // Prints debug messages about jank which was detected (low volume).
     private static final boolean DEBUG_JANK = false;
+    private static final boolean OPTS_INPUT = true;
 
     // Prints debug messages about every frame and callback registered (high volume).
     private static final boolean DEBUG_FRAMES = false;
@@ -151,6 +152,11 @@ protected Choreographer initialValue() {
     private static final int MSG_DO_SCHEDULE_VSYNC = 1;
     private static final int MSG_DO_SCHEDULE_CALLBACK = 2;
 
+    private static final int MOTION_EVENT_ACTION_DOWN = 0;
+    private static final int MOTION_EVENT_ACTION_UP = 1;
+    private static final int MOTION_EVENT_ACTION_MOVE = 2;
+    private static final int MOTION_EVENT_ACTION_CANCEL = 3;
+
     // All frame callbacks posted by applications have this token.
     private static final Object FRAME_CALLBACK_TOKEN = new Object() {
         public String toString() { return "FRAME_CALLBACK_TOKEN"; }
@@ -190,6 +196,13 @@ protected Choreographer initialValue() {
     private DisplayEventReceiver.VsyncEventData mLastVsyncEventData =
             new DisplayEventReceiver.VsyncEventData();
 
+    private int mTouchMoveNum = -1;
+    private int mMotionEventType = -1;
+    private boolean mConsumedMove = false;
+    private boolean mConsumedDown = false;
+    private boolean mIsVsyncScheduled = false;
+    private long mLastTouchOptTimeNanos = 0;
+    private boolean mIsDoFrameProcessing = false;
     /**
      * Contains information about the current frame for jank-tracking,
      * mainly timings of key events along with a bit of metadata about
@@ -304,6 +317,16 @@ public static Choreographer getSfInstance() {
         return sSfThreadInstance.get();
     }
 
+    /**
+     * {@hide}
+     */
+    public void setMotionEventInfo(int motionEventType, int touchMoveNum) {
+        synchronized(this) {
+            mTouchMoveNum = touchMoveNum;
+            mMotionEventType = motionEventType;
+        }
+    }
+
     /**
      * @return The Choreographer of the main thread, if it exists, or {@code null} otherwise.
      * @hide
@@ -636,7 +659,55 @@ public long getLastFrameTimeNanos() {
     private void scheduleFrameLocked(long now) {
         if (!mFrameScheduled) {
             mFrameScheduled = true;
-            if (USE_VSYNC) {
+            if (OPTS_INPUT) {
+                if (!mIsVsyncScheduled) {
+                    long curr = System.nanoTime();
+                    boolean skipFlag = curr - mLastTouchOptTimeNanos < mFrameIntervalNanos;
+                    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "scheduleFrameLocked-mMotionEventType:"
+                                     + mMotionEventType + " mTouchMoveNum:"+ mTouchMoveNum 
+                                     + " mConsumedDown:" + mConsumedDown
+                                     + " mConsumedMove:" + mConsumedMove
+                                     + " mIsDoFrameProcessing:" + mIsDoFrameProcessing
+                                     + " skip:" + skipFlag
+                                     + " diff:" + (curr - mLastTouchOptTimeNanos));
+                    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
+                    synchronized(this) {
+                        switch(mMotionEventType) {
+                            case MOTION_EVENT_ACTION_DOWN:
+                                mConsumedMove = false;
+                                if (!mConsumedDown && !skipFlag && !mIsDoFrameProcessing) {
+                                    Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                    msg.setAsynchronous(true);
+                                    mHandler.sendMessageAtFrontOfQueue(msg);
+                                    mLastTouchOptTimeNanos = System.nanoTime();
+                                    mConsumedDown = true;
+                                    return;
+                                }
+                                break;
+                            case MOTION_EVENT_ACTION_MOVE:
+                                mConsumedDown = false;
+                                //if ((mTouchMoveNum == 1) && !mConsumedMove && !skipFlag) {
+                                if (!mConsumedMove && !skipFlag && !mIsDoFrameProcessing) {
+                                    Message msg = mHandler.obtainMessage(MSG_DO_FRAME);
+                                    msg.setAsynchronous(true);
+                                    mHandler.sendMessageAtFrontOfQueue(msg);
+                                    mLastTouchOptTimeNanos = System.nanoTime();
+                                    mConsumedMove = true;
+                                    return;
+                                }
+                                break;
+                            case MOTION_EVENT_ACTION_UP:
+                            case MOTION_EVENT_ACTION_CANCEL:
+                                mConsumedMove = false;
+                                mConsumedDown = false;
+                                break;
+                            default:
+                                break;
+                        }
+                    }
+                }
+            }
+             if (USE_VSYNC) {
                 if (DEBUG_FRAMES) {
                     Log.d(TAG, "Scheduling next frame on vsync.");
                 }
@@ -703,11 +774,13 @@ void doFrame(long frameTimeNanos, int frame,
         final long startNanos;
         final long frameIntervalNanos = vsyncEventData.frameInterval;
         try {
+            mIsDoFrameProcessing = true;
             if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
                 Trace.traceBegin(Trace.TRACE_TAG_VIEW,
                         "Choreographer#doFrame " + vsyncEventData.id);
             }
             synchronized (mLock) {
+                mIsVsyncScheduled = false;
                 if (!mFrameScheduled) {
                     traceMessage("Frame not scheduled");
                     return; // no work to do
@@ -791,6 +864,7 @@ void doFrame(long frameTimeNanos, int frame,
                     + (endNanos - startNanos) * 0.000001f + " ms, latency "
                     + (startNanos - frameTimeNanos) * 0.000001f + " ms.");
         }
+        mIsDoFrameProcessing = false;
     }
 
     void doCallbacks(int callbackType, long frameTimeNanos, long frameIntervalNanos) {
@@ -881,6 +955,7 @@ private void scheduleVsyncLocked() {
         try {
             Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#scheduleVsyncLocked");
             mDisplayEventReceiver.scheduleVsync();
+            mIsVsyncScheduled = true;
         } finally {
             Trace.traceEnd(Trace.TRACE_TAG_VIEW);
         }
diff --git a/core/java/android/view/InputEventReceiver.java b/core/java/android/view/InputEventReceiver.java
index 25dda5b2e0bb6..8c664c3780d52 100644
--- a/core/java/android/view/InputEventReceiver.java
+++ b/core/java/android/view/InputEventReceiver.java
@@ -49,6 +49,7 @@ public abstract class InputEventReceiver {
 
     // Map from InputEvent sequence numbers to dispatcher sequence numbers.
     private final SparseIntArray mSeqMap = new SparseIntArray();
+    Choreographer mChoreographer;
 
     private static native long nativeInit(WeakReference<InputEventReceiver> receiver,
             InputChannel inputChannel, MessageQueue messageQueue);
@@ -259,6 +260,20 @@ private void dispatchInputEvent(int seq, InputEvent event) {
         onInputEvent(event);
     }
 
+    // Called from native code.
+    @SuppressWarnings("unused")
+    private void dispatchMotionEventInfo(int motionEventType, int touchMoveNum) {
+        try {
+            if (mChoreographer == null)
+                mChoreographer = Choreographer.getInstance();
+
+            if (mChoreographer != null)
+                mChoreographer.setMotionEventInfo(motionEventType, touchMoveNum);
+        } catch (Exception e) {
+            Log.e(TAG, "cannot invoke setMotionEventInfo.");
+        }
+    }
+
     /**
      * Dump the state of this InputEventReceiver to the writer.
      * @param prefix the prefix (typically whitespace padding) to append in front of each line
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index 1244d750e1642..ee426c93710e0 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -116,6 +116,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
 
     @SuppressWarnings("UnusedDeclaration")
     private static final String TAG = "AbsListView";
+    private static final boolean OPTS_INPUT = true;
+    private static final double MOVE_TOUCH_SLOP = 0.6;
+    private static final double TOUCH_SLOP_MIN = 0.6;
+    private static final double TOUCH_SLOP_MAX = 1.0;
 
     /**
      * Disables the transcript mode.
@@ -785,6 +789,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
      */
     private boolean mIsDetaching;
 
+    private boolean mIsFirstTouchMoveEvent = false;
+    private int mMoveAcceleration;
+    private int mNumTouchMoveEvent = 0;
+
     /**
      * Interface definition for a callback to be invoked when the list or grid
      * has been scrolled.
@@ -932,6 +940,20 @@ private void initAbsListView() {
         final ViewConfiguration configuration = ViewConfiguration.get(mContext);
         mTouchSlop = configuration.getScaledTouchSlop();
         mVerticalScrollFactor = configuration.getScaledVerticalScrollFactor();
+        if (OPTS_INPUT) {
+            double touchslopprop = MOVE_TOUCH_SLOP;
+            if (touchslopprop > 0) {
+                if (touchslopprop < TOUCH_SLOP_MIN) {
+                    mMoveAcceleration = (int)(mTouchSlop * TOUCH_SLOP_MIN);
+                } else if ((touchslopprop >= TOUCH_SLOP_MIN) && (touchslopprop < TOUCH_SLOP_MAX)){
+                    mMoveAcceleration = (int)(mTouchSlop * touchslopprop);
+                } else {
+                    mMoveAcceleration = mTouchSlop;
+                }
+            } else {
+                mMoveAcceleration = mTouchSlop;
+            }
+        }
         mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
         mOverscrollDistance = configuration.getScaledOverscrollDistance();
@@ -3541,7 +3563,18 @@ private boolean startScrollIfNeeded(int x, int y, MotionEvent vtev) {
         final int deltaY = y - mMotionY;
         final int distance = Math.abs(deltaY);
         final boolean overscroll = mScrollY != 0;
-        if ((overscroll || distance > mTouchSlop) &&
+        boolean isFarEnough = false;
+        if (OPTS_INPUT) {
+            if (mIsFirstTouchMoveEvent) {
+                isFarEnough = distance > mMoveAcceleration;
+            } else {
+                isFarEnough = distance > mTouchSlop;
+            }
+        } else {
+            isFarEnough = distance > mTouchSlop;
+        }
+
+        if ((overscroll || isFarEnough) &&
                 (getNestedScrollAxes() & SCROLL_AXIS_VERTICAL) == 0) {
             createScrollingCache();
             if (overscroll) {
@@ -3549,7 +3582,11 @@ private boolean startScrollIfNeeded(int x, int y, MotionEvent vtev) {
                 mMotionCorrection = 0;
             } else {
                 mTouchMode = TOUCH_MODE_SCROLL;
-                mMotionCorrection = deltaY > 0 ? mTouchSlop : -mTouchSlop;
+                if (mIsFirstTouchMoveEvent) {
+                    mMotionCorrection = deltaY > 0 ? mMoveAcceleration : -mMoveAcceleration;
+                } else {
+                    mMotionCorrection = deltaY > 0 ? mTouchSlop : -mTouchSlop;
+                }
             }
             removeCallbacks(mPendingCheckForLongPress);
             setPressed(false);
@@ -3897,21 +3934,38 @@ public boolean onTouchEvent(MotionEvent ev) {
         switch (actionMasked) {
             case MotionEvent.ACTION_DOWN: {
                 onTouchDown(ev);
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
             case MotionEvent.ACTION_MOVE: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent++;
+                    if (mNumTouchMoveEvent == 1) {
+                        mIsFirstTouchMoveEvent = true;
+                    } else {
+                        mIsFirstTouchMoveEvent = false;
+                    }
+                }
                 onTouchMove(ev, vtev);
                 break;
             }
 
             case MotionEvent.ACTION_UP: {
                 onTouchUp(ev);
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
             case MotionEvent.ACTION_CANCEL: {
                 onTouchCancel();
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
@@ -3927,6 +3981,9 @@ public boolean onTouchEvent(MotionEvent ev) {
                     mMotionPosition = motionPosition;
                 }
                 mLastY = y;
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
 
@@ -3948,6 +4005,9 @@ public boolean onTouchEvent(MotionEvent ev) {
                     mMotionPosition = motionPosition;
                 }
                 mLastY = y;
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 break;
             }
         }
@@ -4552,6 +4612,9 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
 
         switch (actionMasked) {
             case MotionEvent.ACTION_DOWN: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 int touchMode = mTouchMode;
                 if (touchMode == TOUCH_MODE_OVERFLING || touchMode == TOUCH_MODE_OVERSCROLL) {
                     mMotionCorrection = 0;
@@ -4589,6 +4652,14 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
             }
 
             case MotionEvent.ACTION_MOVE: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent++;
+                    if (mNumTouchMoveEvent == 1) {
+                        mIsFirstTouchMoveEvent = true;
+                    } else {
+                        mIsFirstTouchMoveEvent = false;
+                    }
+                }
                 switch (mTouchMode) {
                     case TOUCH_MODE_DOWN:
                         int pointerIndex = ev.findPointerIndex(mActivePointerId);
@@ -4609,6 +4680,9 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
 
             case MotionEvent.ACTION_CANCEL:
             case MotionEvent.ACTION_UP: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 mTouchMode = TOUCH_MODE_REST;
                 mActivePointerId = INVALID_POINTER;
                 recycleVelocityTracker();
@@ -4618,6 +4692,9 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
             }
 
             case MotionEvent.ACTION_POINTER_UP: {
+                if (OPTS_INPUT) {
+                    mNumTouchMoveEvent = 0;
+                }
                 onSecondaryPointerUp(ev);
                 break;
             }
diff --git a/core/jni/android_view_InputEventReceiver.cpp b/core/jni/android_view_InputEventReceiver.cpp
index a699f912806d0..7096fb6e7e1a1 100644
--- a/core/jni/android_view_InputEventReceiver.cpp
+++ b/core/jni/android_view_InputEventReceiver.cpp
@@ -54,6 +54,7 @@ static struct {
     jmethodID onPointerCaptureEvent;
     jmethodID onDragEvent;
     jmethodID onBatchedInputEventPending;
+    jmethodID dispatchMotionEventInfo;
 } gInputEventReceiverClassInfo;
 
 // Add prefix to the beginning of each line in 'str'
@@ -108,6 +109,8 @@ class NativeInputEventReceiver : public LooperCallback {
     bool mBatchedInputEventPending;
     int mFdEvents;
     std::vector<OutboundEvent> mOutboundQueue;
+    int mLastMotionEventType = -1;
+    int mLastTouchMoveNum = -1;
 
     void setFdEvents(int events);
 
@@ -314,10 +317,34 @@ status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env,
     bool skipCallbacks = false;
     for (;;) {
         uint32_t seq;
+        int motionEventType = -1;
+        int touchMoveNum = -1;
+        bool flag = false;
+
         InputEvent* inputEvent;
 
         status_t status = mInputConsumer.consume(&mInputEventFactory,
-                consumeBatches, frameTime, &seq, &inputEvent);
+                consumeBatches, frameTime, &seq, &inputEvent,
+                &motionEventType, &touchMoveNum, &flag);
+
+        if (!receiverObj.get()) {
+            receiverObj.reset(jniGetReferent(env, mReceiverWeakGlobal));
+            if (!receiverObj.get()) {
+                ALOGW("channel '%s' ~ Receiver object was finalized "
+                        "without being disposed.", getInputChannelName().c_str());
+                return DEAD_OBJECT;
+            }
+        }
+
+        if (flag && ((mLastMotionEventType != motionEventType) ||
+               (mLastTouchMoveNum != touchMoveNum))) {
+           env->CallVoidMethod(receiverObj.get(),
+               gInputEventReceiverClassInfo.dispatchMotionEventInfo, motionEventType, touchMoveNum);
+           mLastMotionEventType = motionEventType;
+           mLastTouchMoveNum = touchMoveNum;
+           flag = false;
+        }
+
         if (status != OK && status != WOULD_BLOCK) {
             ALOGE("channel '%s' ~ Failed to consume input event.  status=%s(%d)",
                   getInputChannelName().c_str(), statusToString(status).c_str(), status);
@@ -611,7 +638,8 @@ int register_android_view_InputEventReceiver(JNIEnv* env) {
     gInputEventReceiverClassInfo.onBatchedInputEventPending =
             GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, "onBatchedInputEventPending",
                              "(I)V");
-
+    gInputEventReceiverClassInfo.dispatchMotionEventInfo = GetMethodIDOrDie(env,
+            gInputEventReceiverClassInfo.clazz, "dispatchMotionEventInfo", "(II)V");
     return res;
 }
 
